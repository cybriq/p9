// generated by go run ./genapi/.; DO NOT EDIT
//
//go:generate go run ./genapi/.

package wallet

import (
	"io"
	"net/rpc"
	"time"

	"github.com/p9c/p9/pkg/qu"

	"github.com/p9c/p9/pkg/btcjson"
	"github.com/p9c/p9/pkg/chainclient"
)

// API stores the channel, parameters and result values from calls via the channel
type API struct {
	Ch     interface{}
	Params interface{}
	Result interface{}
}

// CAPI is the central structure for configuration and access to a net/rpc API access endpoint for this RPC API
type CAPI struct {
	Timeout time.Duration
	quit    qu.C
}

// NewCAPI returns a new CAPI 
func NewCAPI(quit qu.C, timeout ...time.Duration) (c *CAPI) {
	c = &CAPI{quit: quit}
	if len(timeout)>0 {
		c.Timeout = timeout[0]
	} else {
		c.Timeout = time.Second * 5
	}
	return 
}

// CAPIClient is a wrapper around RPC calls
type CAPIClient struct {
	*rpc.Client
}

// NewCAPIClient creates a new client for a kopach_worker. Note that any kind of connection can be used here,
// other than the StdConn
func NewCAPIClient(conn io.ReadWriteCloser) *CAPIClient {
	return &CAPIClient{rpc.NewClient(conn)}
}

type (
	// None means no parameters it is not checked so it can be nil
	None struct{} 
	// AddMultiSigAddressRes is the result from a call to AddMultiSigAddress
	AddMultiSigAddressRes struct { Res *string; e error }
	// CreateMultiSigRes is the result from a call to CreateMultiSig
	CreateMultiSigRes struct { Res *btcjson.CreateMultiSigResult; e error }
	// CreateNewAccountRes is the result from a call to CreateNewAccount
	CreateNewAccountRes struct { Res *None; e error }
	// HandleDropWalletHistoryRes is the result from a call to HandleDropWalletHistory
	HandleDropWalletHistoryRes struct { Res *string; e error }
	// DumpPrivKeyRes is the result from a call to DumpPrivKey
	DumpPrivKeyRes struct { Res *string; e error }
	// GetAccountRes is the result from a call to GetAccount
	GetAccountRes struct { Res *string; e error }
	// GetAccountAddressRes is the result from a call to GetAccountAddress
	GetAccountAddressRes struct { Res *string; e error }
	// GetAddressesByAccountRes is the result from a call to GetAddressesByAccount
	GetAddressesByAccountRes struct { Res *[]string; e error }
	// GetBalanceRes is the result from a call to GetBalance
	GetBalanceRes struct { Res *float64; e error }
	// GetBestBlockRes is the result from a call to GetBestBlock
	GetBestBlockRes struct { Res *btcjson.GetBestBlockResult; e error }
	// GetBestBlockHashRes is the result from a call to GetBestBlockHash
	GetBestBlockHashRes struct { Res *string; e error }
	// GetBlockCountRes is the result from a call to GetBlockCount
	GetBlockCountRes struct { Res *int32; e error }
	// GetInfoRes is the result from a call to GetInfo
	GetInfoRes struct { Res *btcjson.InfoWalletResult; e error }
	// GetNewAddressRes is the result from a call to GetNewAddress
	GetNewAddressRes struct { Res *string; e error }
	// GetRawChangeAddressRes is the result from a call to GetRawChangeAddress
	GetRawChangeAddressRes struct { Res *string; e error }
	// GetReceivedByAccountRes is the result from a call to GetReceivedByAccount
	GetReceivedByAccountRes struct { Res *float64; e error }
	// GetReceivedByAddressRes is the result from a call to GetReceivedByAddress
	GetReceivedByAddressRes struct { Res *float64; e error }
	// GetTransactionRes is the result from a call to GetTransaction
	GetTransactionRes struct { Res *btcjson.GetTransactionResult; e error }
	// GetUnconfirmedBalanceRes is the result from a call to GetUnconfirmedBalance
	GetUnconfirmedBalanceRes struct { Res *float64; e error }
	// HelpNoChainRPCRes is the result from a call to HelpNoChainRPC
	HelpNoChainRPCRes struct { Res *string; e error }
	// ImportPrivKeyRes is the result from a call to ImportPrivKey
	ImportPrivKeyRes struct { Res *None; e error }
	// KeypoolRefillRes is the result from a call to KeypoolRefill
	KeypoolRefillRes struct { Res *None; e error }
	// ListAccountsRes is the result from a call to ListAccounts
	ListAccountsRes struct { Res *map[string]float64; e error }
	// ListAddressTransactionsRes is the result from a call to ListAddressTransactions
	ListAddressTransactionsRes struct { Res *[]btcjson.ListTransactionsResult; e error }
	// ListAllTransactionsRes is the result from a call to ListAllTransactions
	ListAllTransactionsRes struct { Res *[]btcjson.ListTransactionsResult; e error }
	// ListLockUnspentRes is the result from a call to ListLockUnspent
	ListLockUnspentRes struct { Res *[]btcjson.TransactionInput; e error }
	// ListReceivedByAccountRes is the result from a call to ListReceivedByAccount
	ListReceivedByAccountRes struct { Res *[]btcjson.ListReceivedByAccountResult; e error }
	// ListReceivedByAddressRes is the result from a call to ListReceivedByAddress
	ListReceivedByAddressRes struct { Res *btcjson.ListReceivedByAddressResult; e error }
	// ListSinceBlockRes is the result from a call to ListSinceBlock
	ListSinceBlockRes struct { Res *btcjson.ListSinceBlockResult; e error }
	// ListTransactionsRes is the result from a call to ListTransactions
	ListTransactionsRes struct { Res *[]btcjson.ListTransactionsResult; e error }
	// ListUnspentRes is the result from a call to ListUnspent
	ListUnspentRes struct { Res *[]btcjson.ListUnspentResult; e error }
	// RenameAccountRes is the result from a call to RenameAccount
	RenameAccountRes struct { Res *None; e error }
	// LockUnspentRes is the result from a call to LockUnspent
	LockUnspentRes struct { Res *bool; e error }
	// SendManyRes is the result from a call to SendMany
	SendManyRes struct { Res *string; e error }
	// SendToAddressRes is the result from a call to SendToAddress
	SendToAddressRes struct { Res *string; e error }
	// SetTxFeeRes is the result from a call to SetTxFee
	SetTxFeeRes struct { Res *bool; e error }
	// SignMessageRes is the result from a call to SignMessage
	SignMessageRes struct { Res *string; e error }
	// SignRawTransactionRes is the result from a call to SignRawTransaction
	SignRawTransactionRes struct { Res *btcjson.SignRawTransactionResult; e error }
	// ValidateAddressRes is the result from a call to ValidateAddress
	ValidateAddressRes struct { Res *btcjson.ValidateAddressWalletResult; e error }
	// VerifyMessageRes is the result from a call to VerifyMessage
	VerifyMessageRes struct { Res *bool; e error }
	// WalletIsLockedRes is the result from a call to WalletIsLocked
	WalletIsLockedRes struct { Res *bool; e error }
	// WalletLockRes is the result from a call to WalletLock
	WalletLockRes struct { Res *None; e error }
	// WalletPassphraseRes is the result from a call to WalletPassphrase
	WalletPassphraseRes struct { Res *None; e error }
	// WalletPassphraseChangeRes is the result from a call to WalletPassphraseChange
	WalletPassphraseChangeRes struct { Res *None; e error }
)

// RequestHandler is a handler function to handle an unmarshaled and parsed request into a marshalable response.  If the 
// error is a *json.RPCError or any of the above special error classes, the server will respond with the JSON-RPC 
// appropriate error code.  All other errors use the wallet catch-all error code, json.ErrRPCWallet.
type RequestHandler func(interface{}, *Wallet, 
	...*chainclient.RPCClient) (interface{}, error)

// RPCHandlers is all of the RPC calls available
//
// - Handler is the handler function
// 
// - Call is a channel carrying a struct containing parameters and error that is listened to in RunAPI to dispatch the 
//   calls
// 
// - Result is a bundle of command parameters and a channel that the result will be sent back on
//
// Get and save the Result function's return, and you can then call the call functions check, result and wait functions 
// for asynchronous and synchronous calls to RPC functions
var RPCHandlers = map[string]struct {
	Handler          RequestHandler
	// Function variables cannot be compared against anything but nil, so use a boolean to record whether help 
    // generation is necessary.  This is used by the tests to ensure that help can be generated for every implemented 
    // method.
	//
	// A single map and this bool is here is used rather than several maps for the unimplemented handlers so every 
    // method has exactly one handler function.
	//
	// The Return field returns a new channel of the type returned by this function. This makes it possible to use this 
    // for callers to receive a response in the cpc library which implements the functions as channel pipes
	NoHelp bool
	Call   chan API
	Params interface{}
	Result func() API
}{
	"addmultisigaddress":{ 
		Handler: AddMultiSigAddress, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan AddMultiSigAddressRes)} }}, 
	"createmultisig":{ 
		Handler: CreateMultiSig, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan CreateMultiSigRes)} }}, 
	"createnewaccount":{ 
		Handler: CreateNewAccount, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan CreateNewAccountRes)} }}, 
	"dropwallethistory":{ 
		Handler: HandleDropWalletHistory, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan HandleDropWalletHistoryRes)} }}, 
	"dumpprivkey":{ 
		Handler: DumpPrivKey, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan DumpPrivKeyRes)} }}, 
	"getaccount":{ 
		Handler: GetAccount, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetAccountRes)} }}, 
	"getaccountaddress":{ 
		Handler: GetAccountAddress, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetAccountAddressRes)} }}, 
	"getaddressesbyaccount":{ 
		Handler: GetAddressesByAccount, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetAddressesByAccountRes)} }}, 
	"getbalance":{ 
		Handler: GetBalance, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetBalanceRes)} }}, 
	"getbestblock":{ 
		Handler: GetBestBlock, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetBestBlockRes)} }}, 
	"getbestblockhash":{ 
		Handler: GetBestBlockHash, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetBestBlockHashRes)} }}, 
	"getblockcount":{ 
		Handler: GetBlockCount, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetBlockCountRes)} }}, 
	"getinfo":{ 
		Handler: GetInfo, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetInfoRes)} }}, 
	"getnewaddress":{ 
		Handler: GetNewAddress, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetNewAddressRes)} }}, 
	"getrawchangeaddress":{ 
		Handler: GetRawChangeAddress, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetRawChangeAddressRes)} }}, 
	"getreceivedbyaccount":{ 
		Handler: GetReceivedByAccount, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetReceivedByAccountRes)} }}, 
	"getreceivedbyaddress":{ 
		Handler: GetReceivedByAddress, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetReceivedByAddressRes)} }}, 
	"gettransaction":{ 
		Handler: GetTransaction, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetTransactionRes)} }}, 
	"getunconfirmedbalance":{ 
		Handler: GetUnconfirmedBalance, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan GetUnconfirmedBalanceRes)} }}, 
	"help":{ 
		Handler: HelpNoChainRPC, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan HelpNoChainRPCRes)} }}, 
	"importprivkey":{ 
		Handler: ImportPrivKey, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ImportPrivKeyRes)} }}, 
	"keypoolrefill":{ 
		Handler: KeypoolRefill, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan KeypoolRefillRes)} }}, 
	"listaccounts":{ 
		Handler: ListAccounts, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ListAccountsRes)} }}, 
	"listaddresstransactions":{ 
		Handler: ListAddressTransactions, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ListAddressTransactionsRes)} }}, 
	"listalltransactions":{ 
		Handler: ListAllTransactions, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ListAllTransactionsRes)} }}, 
	"listlockunspent":{ 
		Handler: ListLockUnspent, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ListLockUnspentRes)} }}, 
	"listreceivedbyaccount":{ 
		Handler: ListReceivedByAccount, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ListReceivedByAccountRes)} }}, 
	"listreceivedbyaddress":{ 
		Handler: ListReceivedByAddress, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ListReceivedByAddressRes)} }}, 
	"listsinceblock":{ 
		Handler: ListSinceBlock, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ListSinceBlockRes)} }}, 
	"listtransactions":{ 
		Handler: ListTransactions, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ListTransactionsRes)} }}, 
	"listunspent":{ 
		Handler: ListUnspent, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ListUnspentRes)} }}, 
	"renameaccount":{ 
		Handler: RenameAccount, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan RenameAccountRes)} }}, 
	"sendfrom":{ 
		Handler: LockUnspent, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan LockUnspentRes)} }}, 
	"sendmany":{ 
		Handler: SendMany, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan SendManyRes)} }}, 
	"sendtoaddress":{ 
		Handler: SendToAddress, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan SendToAddressRes)} }}, 
	"settxfee":{ 
		Handler: SetTxFee, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan SetTxFeeRes)} }}, 
	"signmessage":{ 
		Handler: SignMessage, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan SignMessageRes)} }}, 
	"signrawtransaction":{ 
		Handler: SignRawTransaction, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan SignRawTransactionRes)} }}, 
	"validateaddress":{ 
		Handler: ValidateAddress, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan ValidateAddressRes)} }}, 
	"verifymessage":{ 
		Handler: VerifyMessage, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan VerifyMessageRes)} }}, 
	"walletislocked":{ 
		Handler: WalletIsLocked, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan WalletIsLockedRes)} }}, 
	"walletlock":{ 
		Handler: WalletLock, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan WalletLockRes)} }}, 
	"walletpassphrase":{ 
		Handler: WalletPassphrase, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan WalletPassphraseRes)} }}, 
	"walletpassphrasechange":{ 
		Handler: WalletPassphraseChange, Call: make(chan API, 32),
		Result: func() API { return API{Ch: make(chan WalletPassphraseChangeRes)} }}, 

}

// API functions
//
// The functions here provide access to the RPC through a convenient set of functions generated for each call in the RPC 
// API to request, check for, access the results and wait on results


// AddMultiSigAddress calls the method with the given parameters
func (a API) AddMultiSigAddress(cmd *btcjson.AddMultisigAddressCmd) (e error) {
	RPCHandlers["addmultisigaddress"].Call <- API{a.Ch, cmd, nil}
	return
}

// AddMultiSigAddressCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) AddMultiSigAddressCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan AddMultiSigAddressRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// AddMultiSigAddressGetRes returns a pointer to the value in the Result field
func (a API) AddMultiSigAddressGetRes() (out *string, e error) {
	out, _ = a.Result.(*string)
	e, _ = a.Result.(error)
	return 
}

// AddMultiSigAddressWait calls the method and blocks until it returns or 5 seconds passes
func (a API) AddMultiSigAddressWait(cmd *btcjson.AddMultisigAddressCmd) (out *string, e error) {
	RPCHandlers["addmultisigaddress"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan AddMultiSigAddressRes):
		out, e = o.Res, o.e
	}
	return
}

// CreateMultiSig calls the method with the given parameters
func (a API) CreateMultiSig(cmd *btcjson.CreateMultisigCmd) (e error) {
	RPCHandlers["createmultisig"].Call <- API{a.Ch, cmd, nil}
	return
}

// CreateMultiSigCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) CreateMultiSigCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan CreateMultiSigRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// CreateMultiSigGetRes returns a pointer to the value in the Result field
func (a API) CreateMultiSigGetRes() (out *btcjson.CreateMultiSigResult, e error) {
	out, _ = a.Result.(*btcjson.CreateMultiSigResult)
	e, _ = a.Result.(error)
	return 
}

// CreateMultiSigWait calls the method and blocks until it returns or 5 seconds passes
func (a API) CreateMultiSigWait(cmd *btcjson.CreateMultisigCmd) (out *btcjson.CreateMultiSigResult, e error) {
	RPCHandlers["createmultisig"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan CreateMultiSigRes):
		out, e = o.Res, o.e
	}
	return
}

// CreateNewAccount calls the method with the given parameters
func (a API) CreateNewAccount(cmd *btcjson.CreateNewAccountCmd) (e error) {
	RPCHandlers["createnewaccount"].Call <- API{a.Ch, cmd, nil}
	return
}

// CreateNewAccountCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) CreateNewAccountCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan CreateNewAccountRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// CreateNewAccountGetRes returns a pointer to the value in the Result field
func (a API) CreateNewAccountGetRes() (out *None, e error) {
	out, _ = a.Result.(*None)
	e, _ = a.Result.(error)
	return 
}

// CreateNewAccountWait calls the method and blocks until it returns or 5 seconds passes
func (a API) CreateNewAccountWait(cmd *btcjson.CreateNewAccountCmd) (out *None, e error) {
	RPCHandlers["createnewaccount"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan CreateNewAccountRes):
		out, e = o.Res, o.e
	}
	return
}

// HandleDropWalletHistory calls the method with the given parameters
func (a API) HandleDropWalletHistory(cmd *None) (e error) {
	RPCHandlers["dropwallethistory"].Call <- API{a.Ch, cmd, nil}
	return
}

// HandleDropWalletHistoryCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) HandleDropWalletHistoryCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan HandleDropWalletHistoryRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// HandleDropWalletHistoryGetRes returns a pointer to the value in the Result field
func (a API) HandleDropWalletHistoryGetRes() (out *string, e error) {
	out, _ = a.Result.(*string)
	e, _ = a.Result.(error)
	return 
}

// HandleDropWalletHistoryWait calls the method and blocks until it returns or 5 seconds passes
func (a API) HandleDropWalletHistoryWait(cmd *None) (out *string, e error) {
	RPCHandlers["dropwallethistory"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan HandleDropWalletHistoryRes):
		out, e = o.Res, o.e
	}
	return
}

// DumpPrivKey calls the method with the given parameters
func (a API) DumpPrivKey(cmd *btcjson.DumpPrivKeyCmd) (e error) {
	RPCHandlers["dumpprivkey"].Call <- API{a.Ch, cmd, nil}
	return
}

// DumpPrivKeyCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) DumpPrivKeyCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan DumpPrivKeyRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// DumpPrivKeyGetRes returns a pointer to the value in the Result field
func (a API) DumpPrivKeyGetRes() (out *string, e error) {
	out, _ = a.Result.(*string)
	e, _ = a.Result.(error)
	return 
}

// DumpPrivKeyWait calls the method and blocks until it returns or 5 seconds passes
func (a API) DumpPrivKeyWait(cmd *btcjson.DumpPrivKeyCmd) (out *string, e error) {
	RPCHandlers["dumpprivkey"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan DumpPrivKeyRes):
		out, e = o.Res, o.e
	}
	return
}

// GetAccount calls the method with the given parameters
func (a API) GetAccount(cmd *btcjson.GetAccountCmd) (e error) {
	RPCHandlers["getaccount"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetAccountCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetAccountCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan GetAccountRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetAccountGetRes returns a pointer to the value in the Result field
func (a API) GetAccountGetRes() (out *string, e error) {
	out, _ = a.Result.(*string)
	e, _ = a.Result.(error)
	return 
}

// GetAccountWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetAccountWait(cmd *btcjson.GetAccountCmd) (out *string, e error) {
	RPCHandlers["getaccount"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan GetAccountRes):
		out, e = o.Res, o.e
	}
	return
}

// GetAccountAddress calls the method with the given parameters
func (a API) GetAccountAddress(cmd *btcjson.GetAccountAddressCmd) (e error) {
	RPCHandlers["getaccountaddress"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetAccountAddressCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetAccountAddressCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan GetAccountAddressRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetAccountAddressGetRes returns a pointer to the value in the Result field
func (a API) GetAccountAddressGetRes() (out *string, e error) {
	out, _ = a.Result.(*string)
	e, _ = a.Result.(error)
	return 
}

// GetAccountAddressWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetAccountAddressWait(cmd *btcjson.GetAccountAddressCmd) (out *string, e error) {
	RPCHandlers["getaccountaddress"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan GetAccountAddressRes):
		out, e = o.Res, o.e
	}
	return
}

// GetAddressesByAccount calls the method with the given parameters
func (a API) GetAddressesByAccount(cmd *btcjson.GetAddressesByAccountCmd) (e error) {
	RPCHandlers["getaddressesbyaccount"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetAddressesByAccountCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetAddressesByAccountCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan GetAddressesByAccountRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetAddressesByAccountGetRes returns a pointer to the value in the Result field
func (a API) GetAddressesByAccountGetRes() (out *[]string, e error) {
	out, _ = a.Result.(*[]string)
	e, _ = a.Result.(error)
	return 
}

// GetAddressesByAccountWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetAddressesByAccountWait(cmd *btcjson.GetAddressesByAccountCmd) (out *[]string, e error) {
	RPCHandlers["getaddressesbyaccount"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan GetAddressesByAccountRes):
		out, e = o.Res, o.e
	}
	return
}

// GetBalance calls the method with the given parameters
func (a API) GetBalance(cmd *btcjson.GetBalanceCmd) (e error) {
	RPCHandlers["getbalance"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetBalanceCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetBalanceCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan GetBalanceRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetBalanceGetRes returns a pointer to the value in the Result field
func (a API) GetBalanceGetRes() (out *float64, e error) {
	out, _ = a.Result.(*float64)
	e, _ = a.Result.(error)
	return 
}

// GetBalanceWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetBalanceWait(cmd *btcjson.GetBalanceCmd) (out *float64, e error) {
	RPCHandlers["getbalance"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan GetBalanceRes):
		out, e = o.Res, o.e
	}
	return
}

// GetBestBlock calls the method with the given parameters
func (a API) GetBestBlock(cmd *None) (e error) {
	RPCHandlers["getbestblock"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetBestBlockCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetBestBlockCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan GetBestBlockRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetBestBlockGetRes returns a pointer to the value in the Result field
func (a API) GetBestBlockGetRes() (out *btcjson.GetBestBlockResult, e error) {
	out, _ = a.Result.(*btcjson.GetBestBlockResult)
	e, _ = a.Result.(error)
	return 
}

// GetBestBlockWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetBestBlockWait(cmd *None) (out *btcjson.GetBestBlockResult, e error) {
	RPCHandlers["getbestblock"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan GetBestBlockRes):
		out, e = o.Res, o.e
	}
	return
}

// GetBestBlockHash calls the method with the given parameters
func (a API) GetBestBlockHash(cmd *None) (e error) {
	RPCHandlers["getbestblockhash"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetBestBlockHashCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetBestBlockHashCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan GetBestBlockHashRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetBestBlockHashGetRes returns a pointer to the value in the Result field
func (a API) GetBestBlockHashGetRes() (out *string, e error) {
	out, _ = a.Result.(*string)
	e, _ = a.Result.(error)
	return 
}

// GetBestBlockHashWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetBestBlockHashWait(cmd *None) (out *string, e error) {
	RPCHandlers["getbestblockhash"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan GetBestBlockHashRes):
		out, e = o.Res, o.e
	}
	return
}

// GetBlockCount calls the method with the given parameters
func (a API) GetBlockCount(cmd *None) (e error) {
	RPCHandlers["getblockcount"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetBlockCountCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetBlockCountCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan GetBlockCountRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetBlockCountGetRes returns a pointer to the value in the Result field
func (a API) GetBlockCountGetRes() (out *int32, e error) {
	out, _ = a.Result.(*int32)
	e, _ = a.Result.(error)
	return 
}

// GetBlockCountWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetBlockCountWait(cmd *None) (out *int32, e error) {
	RPCHandlers["getblockcount"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan GetBlockCountRes):
		out, e = o.Res, o.e
	}
	return
}

// GetInfo calls the method with the given parameters
func (a API) GetInfo(cmd *None) (e error) {
	RPCHandlers["getinfo"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetInfoCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetInfoCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan GetInfoRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetInfoGetRes returns a pointer to the value in the Result field
func (a API) GetInfoGetRes() (out *btcjson.InfoWalletResult, e error) {
	out, _ = a.Result.(*btcjson.InfoWalletResult)
	e, _ = a.Result.(error)
	return 
}

// GetInfoWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetInfoWait(cmd *None) (out *btcjson.InfoWalletResult, e error) {
	RPCHandlers["getinfo"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan GetInfoRes):
		out, e = o.Res, o.e
	}
	return
}

// GetNewAddress calls the method with the given parameters
func (a API) GetNewAddress(cmd *btcjson.GetNewAddressCmd) (e error) {
	RPCHandlers["getnewaddress"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetNewAddressCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetNewAddressCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan GetNewAddressRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetNewAddressGetRes returns a pointer to the value in the Result field
func (a API) GetNewAddressGetRes() (out *string, e error) {
	out, _ = a.Result.(*string)
	e, _ = a.Result.(error)
	return 
}

// GetNewAddressWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetNewAddressWait(cmd *btcjson.GetNewAddressCmd) (out *string, e error) {
	RPCHandlers["getnewaddress"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan GetNewAddressRes):
		out, e = o.Res, o.e
	}
	return
}

// GetRawChangeAddress calls the method with the given parameters
func (a API) GetRawChangeAddress(cmd *btcjson.GetRawChangeAddressCmd) (e error) {
	RPCHandlers["getrawchangeaddress"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetRawChangeAddressCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetRawChangeAddressCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan GetRawChangeAddressRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetRawChangeAddressGetRes returns a pointer to the value in the Result field
func (a API) GetRawChangeAddressGetRes() (out *string, e error) {
	out, _ = a.Result.(*string)
	e, _ = a.Result.(error)
	return 
}

// GetRawChangeAddressWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetRawChangeAddressWait(cmd *btcjson.GetRawChangeAddressCmd) (out *string, e error) {
	RPCHandlers["getrawchangeaddress"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan GetRawChangeAddressRes):
		out, e = o.Res, o.e
	}
	return
}

// GetReceivedByAccount calls the method with the given parameters
func (a API) GetReceivedByAccount(cmd *btcjson.GetReceivedByAccountCmd) (e error) {
	RPCHandlers["getreceivedbyaccount"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetReceivedByAccountCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetReceivedByAccountCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan GetReceivedByAccountRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetReceivedByAccountGetRes returns a pointer to the value in the Result field
func (a API) GetReceivedByAccountGetRes() (out *float64, e error) {
	out, _ = a.Result.(*float64)
	e, _ = a.Result.(error)
	return 
}

// GetReceivedByAccountWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetReceivedByAccountWait(cmd *btcjson.GetReceivedByAccountCmd) (out *float64, e error) {
	RPCHandlers["getreceivedbyaccount"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan GetReceivedByAccountRes):
		out, e = o.Res, o.e
	}
	return
}

// GetReceivedByAddress calls the method with the given parameters
func (a API) GetReceivedByAddress(cmd *btcjson.GetReceivedByAddressCmd) (e error) {
	RPCHandlers["getreceivedbyaddress"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetReceivedByAddressCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetReceivedByAddressCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan GetReceivedByAddressRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetReceivedByAddressGetRes returns a pointer to the value in the Result field
func (a API) GetReceivedByAddressGetRes() (out *float64, e error) {
	out, _ = a.Result.(*float64)
	e, _ = a.Result.(error)
	return 
}

// GetReceivedByAddressWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetReceivedByAddressWait(cmd *btcjson.GetReceivedByAddressCmd) (out *float64, e error) {
	RPCHandlers["getreceivedbyaddress"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan GetReceivedByAddressRes):
		out, e = o.Res, o.e
	}
	return
}

// GetTransaction calls the method with the given parameters
func (a API) GetTransaction(cmd *btcjson.GetTransactionCmd) (e error) {
	RPCHandlers["gettransaction"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetTransactionCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetTransactionCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan GetTransactionRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetTransactionGetRes returns a pointer to the value in the Result field
func (a API) GetTransactionGetRes() (out *btcjson.GetTransactionResult, e error) {
	out, _ = a.Result.(*btcjson.GetTransactionResult)
	e, _ = a.Result.(error)
	return 
}

// GetTransactionWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetTransactionWait(cmd *btcjson.GetTransactionCmd) (out *btcjson.GetTransactionResult, e error) {
	RPCHandlers["gettransaction"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan GetTransactionRes):
		out, e = o.Res, o.e
	}
	return
}

// GetUnconfirmedBalance calls the method with the given parameters
func (a API) GetUnconfirmedBalance(cmd *btcjson.GetUnconfirmedBalanceCmd) (e error) {
	RPCHandlers["getunconfirmedbalance"].Call <- API{a.Ch, cmd, nil}
	return
}

// GetUnconfirmedBalanceCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) GetUnconfirmedBalanceCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan GetUnconfirmedBalanceRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// GetUnconfirmedBalanceGetRes returns a pointer to the value in the Result field
func (a API) GetUnconfirmedBalanceGetRes() (out *float64, e error) {
	out, _ = a.Result.(*float64)
	e, _ = a.Result.(error)
	return 
}

// GetUnconfirmedBalanceWait calls the method and blocks until it returns or 5 seconds passes
func (a API) GetUnconfirmedBalanceWait(cmd *btcjson.GetUnconfirmedBalanceCmd) (out *float64, e error) {
	RPCHandlers["getunconfirmedbalance"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan GetUnconfirmedBalanceRes):
		out, e = o.Res, o.e
	}
	return
}

// HelpNoChainRPC calls the method with the given parameters
func (a API) HelpNoChainRPC(cmd btcjson.HelpCmd) (e error) {
	RPCHandlers["help"].Call <- API{a.Ch, cmd, nil}
	return
}

// HelpNoChainRPCCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) HelpNoChainRPCCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan HelpNoChainRPCRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// HelpNoChainRPCGetRes returns a pointer to the value in the Result field
func (a API) HelpNoChainRPCGetRes() (out *string, e error) {
	out, _ = a.Result.(*string)
	e, _ = a.Result.(error)
	return 
}

// HelpNoChainRPCWait calls the method and blocks until it returns or 5 seconds passes
func (a API) HelpNoChainRPCWait(cmd btcjson.HelpCmd) (out *string, e error) {
	RPCHandlers["help"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan HelpNoChainRPCRes):
		out, e = o.Res, o.e
	}
	return
}

// ImportPrivKey calls the method with the given parameters
func (a API) ImportPrivKey(cmd *btcjson.ImportPrivKeyCmd) (e error) {
	RPCHandlers["importprivkey"].Call <- API{a.Ch, cmd, nil}
	return
}

// ImportPrivKeyCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ImportPrivKeyCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan ImportPrivKeyRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ImportPrivKeyGetRes returns a pointer to the value in the Result field
func (a API) ImportPrivKeyGetRes() (out *None, e error) {
	out, _ = a.Result.(*None)
	e, _ = a.Result.(error)
	return 
}

// ImportPrivKeyWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ImportPrivKeyWait(cmd *btcjson.ImportPrivKeyCmd) (out *None, e error) {
	RPCHandlers["importprivkey"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan ImportPrivKeyRes):
		out, e = o.Res, o.e
	}
	return
}

// KeypoolRefill calls the method with the given parameters
func (a API) KeypoolRefill(cmd *None) (e error) {
	RPCHandlers["keypoolrefill"].Call <- API{a.Ch, cmd, nil}
	return
}

// KeypoolRefillCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) KeypoolRefillCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan KeypoolRefillRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// KeypoolRefillGetRes returns a pointer to the value in the Result field
func (a API) KeypoolRefillGetRes() (out *None, e error) {
	out, _ = a.Result.(*None)
	e, _ = a.Result.(error)
	return 
}

// KeypoolRefillWait calls the method and blocks until it returns or 5 seconds passes
func (a API) KeypoolRefillWait(cmd *None) (out *None, e error) {
	RPCHandlers["keypoolrefill"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan KeypoolRefillRes):
		out, e = o.Res, o.e
	}
	return
}

// ListAccounts calls the method with the given parameters
func (a API) ListAccounts(cmd *btcjson.ListAccountsCmd) (e error) {
	RPCHandlers["listaccounts"].Call <- API{a.Ch, cmd, nil}
	return
}

// ListAccountsCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ListAccountsCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan ListAccountsRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ListAccountsGetRes returns a pointer to the value in the Result field
func (a API) ListAccountsGetRes() (out *map[string]float64, e error) {
	out, _ = a.Result.(*map[string]float64)
	e, _ = a.Result.(error)
	return 
}

// ListAccountsWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ListAccountsWait(cmd *btcjson.ListAccountsCmd) (out *map[string]float64, e error) {
	RPCHandlers["listaccounts"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan ListAccountsRes):
		out, e = o.Res, o.e
	}
	return
}

// ListAddressTransactions calls the method with the given parameters
func (a API) ListAddressTransactions(cmd *btcjson.ListAddressTransactionsCmd) (e error) {
	RPCHandlers["listaddresstransactions"].Call <- API{a.Ch, cmd, nil}
	return
}

// ListAddressTransactionsCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ListAddressTransactionsCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan ListAddressTransactionsRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ListAddressTransactionsGetRes returns a pointer to the value in the Result field
func (a API) ListAddressTransactionsGetRes() (out *[]btcjson.ListTransactionsResult, e error) {
	out, _ = a.Result.(*[]btcjson.ListTransactionsResult)
	e, _ = a.Result.(error)
	return 
}

// ListAddressTransactionsWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ListAddressTransactionsWait(cmd *btcjson.ListAddressTransactionsCmd) (out *[]btcjson.ListTransactionsResult, e error) {
	RPCHandlers["listaddresstransactions"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan ListAddressTransactionsRes):
		out, e = o.Res, o.e
	}
	return
}

// ListAllTransactions calls the method with the given parameters
func (a API) ListAllTransactions(cmd *btcjson.ListAllTransactionsCmd) (e error) {
	RPCHandlers["listalltransactions"].Call <- API{a.Ch, cmd, nil}
	return
}

// ListAllTransactionsCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ListAllTransactionsCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan ListAllTransactionsRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ListAllTransactionsGetRes returns a pointer to the value in the Result field
func (a API) ListAllTransactionsGetRes() (out *[]btcjson.ListTransactionsResult, e error) {
	out, _ = a.Result.(*[]btcjson.ListTransactionsResult)
	e, _ = a.Result.(error)
	return 
}

// ListAllTransactionsWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ListAllTransactionsWait(cmd *btcjson.ListAllTransactionsCmd) (out *[]btcjson.ListTransactionsResult, e error) {
	RPCHandlers["listalltransactions"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan ListAllTransactionsRes):
		out, e = o.Res, o.e
	}
	return
}

// ListLockUnspent calls the method with the given parameters
func (a API) ListLockUnspent(cmd *None) (e error) {
	RPCHandlers["listlockunspent"].Call <- API{a.Ch, cmd, nil}
	return
}

// ListLockUnspentCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ListLockUnspentCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan ListLockUnspentRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ListLockUnspentGetRes returns a pointer to the value in the Result field
func (a API) ListLockUnspentGetRes() (out *[]btcjson.TransactionInput, e error) {
	out, _ = a.Result.(*[]btcjson.TransactionInput)
	e, _ = a.Result.(error)
	return 
}

// ListLockUnspentWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ListLockUnspentWait(cmd *None) (out *[]btcjson.TransactionInput, e error) {
	RPCHandlers["listlockunspent"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan ListLockUnspentRes):
		out, e = o.Res, o.e
	}
	return
}

// ListReceivedByAccount calls the method with the given parameters
func (a API) ListReceivedByAccount(cmd *btcjson.ListReceivedByAccountCmd) (e error) {
	RPCHandlers["listreceivedbyaccount"].Call <- API{a.Ch, cmd, nil}
	return
}

// ListReceivedByAccountCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ListReceivedByAccountCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan ListReceivedByAccountRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ListReceivedByAccountGetRes returns a pointer to the value in the Result field
func (a API) ListReceivedByAccountGetRes() (out *[]btcjson.ListReceivedByAccountResult, e error) {
	out, _ = a.Result.(*[]btcjson.ListReceivedByAccountResult)
	e, _ = a.Result.(error)
	return 
}

// ListReceivedByAccountWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ListReceivedByAccountWait(cmd *btcjson.ListReceivedByAccountCmd) (out *[]btcjson.ListReceivedByAccountResult, e error) {
	RPCHandlers["listreceivedbyaccount"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan ListReceivedByAccountRes):
		out, e = o.Res, o.e
	}
	return
}

// ListReceivedByAddress calls the method with the given parameters
func (a API) ListReceivedByAddress(cmd *btcjson.ListReceivedByAddressCmd) (e error) {
	RPCHandlers["listreceivedbyaddress"].Call <- API{a.Ch, cmd, nil}
	return
}

// ListReceivedByAddressCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ListReceivedByAddressCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan ListReceivedByAddressRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ListReceivedByAddressGetRes returns a pointer to the value in the Result field
func (a API) ListReceivedByAddressGetRes() (out *btcjson.ListReceivedByAddressResult, e error) {
	out, _ = a.Result.(*btcjson.ListReceivedByAddressResult)
	e, _ = a.Result.(error)
	return 
}

// ListReceivedByAddressWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ListReceivedByAddressWait(cmd *btcjson.ListReceivedByAddressCmd) (out *btcjson.ListReceivedByAddressResult, e error) {
	RPCHandlers["listreceivedbyaddress"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan ListReceivedByAddressRes):
		out, e = o.Res, o.e
	}
	return
}

// ListSinceBlock calls the method with the given parameters
func (a API) ListSinceBlock(cmd btcjson.ListSinceBlockCmd) (e error) {
	RPCHandlers["listsinceblock"].Call <- API{a.Ch, cmd, nil}
	return
}

// ListSinceBlockCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ListSinceBlockCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan ListSinceBlockRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ListSinceBlockGetRes returns a pointer to the value in the Result field
func (a API) ListSinceBlockGetRes() (out *btcjson.ListSinceBlockResult, e error) {
	out, _ = a.Result.(*btcjson.ListSinceBlockResult)
	e, _ = a.Result.(error)
	return 
}

// ListSinceBlockWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ListSinceBlockWait(cmd btcjson.ListSinceBlockCmd) (out *btcjson.ListSinceBlockResult, e error) {
	RPCHandlers["listsinceblock"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan ListSinceBlockRes):
		out, e = o.Res, o.e
	}
	return
}

// ListTransactions calls the method with the given parameters
func (a API) ListTransactions(cmd *btcjson.ListTransactionsCmd) (e error) {
	RPCHandlers["listtransactions"].Call <- API{a.Ch, cmd, nil}
	return
}

// ListTransactionsCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ListTransactionsCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan ListTransactionsRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ListTransactionsGetRes returns a pointer to the value in the Result field
func (a API) ListTransactionsGetRes() (out *[]btcjson.ListTransactionsResult, e error) {
	out, _ = a.Result.(*[]btcjson.ListTransactionsResult)
	e, _ = a.Result.(error)
	return 
}

// ListTransactionsWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ListTransactionsWait(cmd *btcjson.ListTransactionsCmd) (out *[]btcjson.ListTransactionsResult, e error) {
	RPCHandlers["listtransactions"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan ListTransactionsRes):
		out, e = o.Res, o.e
	}
	return
}

// ListUnspent calls the method with the given parameters
func (a API) ListUnspent(cmd *btcjson.ListUnspentCmd) (e error) {
	RPCHandlers["listunspent"].Call <- API{a.Ch, cmd, nil}
	return
}

// ListUnspentCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ListUnspentCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan ListUnspentRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ListUnspentGetRes returns a pointer to the value in the Result field
func (a API) ListUnspentGetRes() (out *[]btcjson.ListUnspentResult, e error) {
	out, _ = a.Result.(*[]btcjson.ListUnspentResult)
	e, _ = a.Result.(error)
	return 
}

// ListUnspentWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ListUnspentWait(cmd *btcjson.ListUnspentCmd) (out *[]btcjson.ListUnspentResult, e error) {
	RPCHandlers["listunspent"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan ListUnspentRes):
		out, e = o.Res, o.e
	}
	return
}

// RenameAccount calls the method with the given parameters
func (a API) RenameAccount(cmd *btcjson.RenameAccountCmd) (e error) {
	RPCHandlers["renameaccount"].Call <- API{a.Ch, cmd, nil}
	return
}

// RenameAccountCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) RenameAccountCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan RenameAccountRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// RenameAccountGetRes returns a pointer to the value in the Result field
func (a API) RenameAccountGetRes() (out *None, e error) {
	out, _ = a.Result.(*None)
	e, _ = a.Result.(error)
	return 
}

// RenameAccountWait calls the method and blocks until it returns or 5 seconds passes
func (a API) RenameAccountWait(cmd *btcjson.RenameAccountCmd) (out *None, e error) {
	RPCHandlers["renameaccount"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan RenameAccountRes):
		out, e = o.Res, o.e
	}
	return
}

// LockUnspent calls the method with the given parameters
func (a API) LockUnspent(cmd btcjson.LockUnspentCmd) (e error) {
	RPCHandlers["sendfrom"].Call <- API{a.Ch, cmd, nil}
	return
}

// LockUnspentCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) LockUnspentCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan LockUnspentRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// LockUnspentGetRes returns a pointer to the value in the Result field
func (a API) LockUnspentGetRes() (out *bool, e error) {
	out, _ = a.Result.(*bool)
	e, _ = a.Result.(error)
	return 
}

// LockUnspentWait calls the method and blocks until it returns or 5 seconds passes
func (a API) LockUnspentWait(cmd btcjson.LockUnspentCmd) (out *bool, e error) {
	RPCHandlers["sendfrom"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan LockUnspentRes):
		out, e = o.Res, o.e
	}
	return
}

// SendMany calls the method with the given parameters
func (a API) SendMany(cmd *btcjson.SendManyCmd) (e error) {
	RPCHandlers["sendmany"].Call <- API{a.Ch, cmd, nil}
	return
}

// SendManyCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) SendManyCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan SendManyRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// SendManyGetRes returns a pointer to the value in the Result field
func (a API) SendManyGetRes() (out *string, e error) {
	out, _ = a.Result.(*string)
	e, _ = a.Result.(error)
	return 
}

// SendManyWait calls the method and blocks until it returns or 5 seconds passes
func (a API) SendManyWait(cmd *btcjson.SendManyCmd) (out *string, e error) {
	RPCHandlers["sendmany"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan SendManyRes):
		out, e = o.Res, o.e
	}
	return
}

// SendToAddress calls the method with the given parameters
func (a API) SendToAddress(cmd *btcjson.SendToAddressCmd) (e error) {
	RPCHandlers["sendtoaddress"].Call <- API{a.Ch, cmd, nil}
	return
}

// SendToAddressCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) SendToAddressCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan SendToAddressRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// SendToAddressGetRes returns a pointer to the value in the Result field
func (a API) SendToAddressGetRes() (out *string, e error) {
	out, _ = a.Result.(*string)
	e, _ = a.Result.(error)
	return 
}

// SendToAddressWait calls the method and blocks until it returns or 5 seconds passes
func (a API) SendToAddressWait(cmd *btcjson.SendToAddressCmd) (out *string, e error) {
	RPCHandlers["sendtoaddress"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan SendToAddressRes):
		out, e = o.Res, o.e
	}
	return
}

// SetTxFee calls the method with the given parameters
func (a API) SetTxFee(cmd *btcjson.SetTxFeeCmd) (e error) {
	RPCHandlers["settxfee"].Call <- API{a.Ch, cmd, nil}
	return
}

// SetTxFeeCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) SetTxFeeCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan SetTxFeeRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// SetTxFeeGetRes returns a pointer to the value in the Result field
func (a API) SetTxFeeGetRes() (out *bool, e error) {
	out, _ = a.Result.(*bool)
	e, _ = a.Result.(error)
	return 
}

// SetTxFeeWait calls the method and blocks until it returns or 5 seconds passes
func (a API) SetTxFeeWait(cmd *btcjson.SetTxFeeCmd) (out *bool, e error) {
	RPCHandlers["settxfee"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan SetTxFeeRes):
		out, e = o.Res, o.e
	}
	return
}

// SignMessage calls the method with the given parameters
func (a API) SignMessage(cmd *btcjson.SignMessageCmd) (e error) {
	RPCHandlers["signmessage"].Call <- API{a.Ch, cmd, nil}
	return
}

// SignMessageCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) SignMessageCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan SignMessageRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// SignMessageGetRes returns a pointer to the value in the Result field
func (a API) SignMessageGetRes() (out *string, e error) {
	out, _ = a.Result.(*string)
	e, _ = a.Result.(error)
	return 
}

// SignMessageWait calls the method and blocks until it returns or 5 seconds passes
func (a API) SignMessageWait(cmd *btcjson.SignMessageCmd) (out *string, e error) {
	RPCHandlers["signmessage"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan SignMessageRes):
		out, e = o.Res, o.e
	}
	return
}

// SignRawTransaction calls the method with the given parameters
func (a API) SignRawTransaction(cmd btcjson.SignRawTransactionCmd) (e error) {
	RPCHandlers["signrawtransaction"].Call <- API{a.Ch, cmd, nil}
	return
}

// SignRawTransactionCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) SignRawTransactionCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan SignRawTransactionRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// SignRawTransactionGetRes returns a pointer to the value in the Result field
func (a API) SignRawTransactionGetRes() (out *btcjson.SignRawTransactionResult, e error) {
	out, _ = a.Result.(*btcjson.SignRawTransactionResult)
	e, _ = a.Result.(error)
	return 
}

// SignRawTransactionWait calls the method and blocks until it returns or 5 seconds passes
func (a API) SignRawTransactionWait(cmd btcjson.SignRawTransactionCmd) (out *btcjson.SignRawTransactionResult, e error) {
	RPCHandlers["signrawtransaction"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan SignRawTransactionRes):
		out, e = o.Res, o.e
	}
	return
}

// ValidateAddress calls the method with the given parameters
func (a API) ValidateAddress(cmd *btcjson.ValidateAddressCmd) (e error) {
	RPCHandlers["validateaddress"].Call <- API{a.Ch, cmd, nil}
	return
}

// ValidateAddressCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) ValidateAddressCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan ValidateAddressRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// ValidateAddressGetRes returns a pointer to the value in the Result field
func (a API) ValidateAddressGetRes() (out *btcjson.ValidateAddressWalletResult, e error) {
	out, _ = a.Result.(*btcjson.ValidateAddressWalletResult)
	e, _ = a.Result.(error)
	return 
}

// ValidateAddressWait calls the method and blocks until it returns or 5 seconds passes
func (a API) ValidateAddressWait(cmd *btcjson.ValidateAddressCmd) (out *btcjson.ValidateAddressWalletResult, e error) {
	RPCHandlers["validateaddress"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan ValidateAddressRes):
		out, e = o.Res, o.e
	}
	return
}

// VerifyMessage calls the method with the given parameters
func (a API) VerifyMessage(cmd *btcjson.VerifyMessageCmd) (e error) {
	RPCHandlers["verifymessage"].Call <- API{a.Ch, cmd, nil}
	return
}

// VerifyMessageCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) VerifyMessageCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan VerifyMessageRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// VerifyMessageGetRes returns a pointer to the value in the Result field
func (a API) VerifyMessageGetRes() (out *bool, e error) {
	out, _ = a.Result.(*bool)
	e, _ = a.Result.(error)
	return 
}

// VerifyMessageWait calls the method and blocks until it returns or 5 seconds passes
func (a API) VerifyMessageWait(cmd *btcjson.VerifyMessageCmd) (out *bool, e error) {
	RPCHandlers["verifymessage"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan VerifyMessageRes):
		out, e = o.Res, o.e
	}
	return
}

// WalletIsLocked calls the method with the given parameters
func (a API) WalletIsLocked(cmd *None) (e error) {
	RPCHandlers["walletislocked"].Call <- API{a.Ch, cmd, nil}
	return
}

// WalletIsLockedCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) WalletIsLockedCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan WalletIsLockedRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// WalletIsLockedGetRes returns a pointer to the value in the Result field
func (a API) WalletIsLockedGetRes() (out *bool, e error) {
	out, _ = a.Result.(*bool)
	e, _ = a.Result.(error)
	return 
}

// WalletIsLockedWait calls the method and blocks until it returns or 5 seconds passes
func (a API) WalletIsLockedWait(cmd *None) (out *bool, e error) {
	RPCHandlers["walletislocked"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan WalletIsLockedRes):
		out, e = o.Res, o.e
	}
	return
}

// WalletLock calls the method with the given parameters
func (a API) WalletLock(cmd *None) (e error) {
	RPCHandlers["walletlock"].Call <- API{a.Ch, cmd, nil}
	return
}

// WalletLockCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) WalletLockCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan WalletLockRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// WalletLockGetRes returns a pointer to the value in the Result field
func (a API) WalletLockGetRes() (out *None, e error) {
	out, _ = a.Result.(*None)
	e, _ = a.Result.(error)
	return 
}

// WalletLockWait calls the method and blocks until it returns or 5 seconds passes
func (a API) WalletLockWait(cmd *None) (out *None, e error) {
	RPCHandlers["walletlock"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan WalletLockRes):
		out, e = o.Res, o.e
	}
	return
}

// WalletPassphrase calls the method with the given parameters
func (a API) WalletPassphrase(cmd *btcjson.WalletPassphraseCmd) (e error) {
	RPCHandlers["walletpassphrase"].Call <- API{a.Ch, cmd, nil}
	return
}

// WalletPassphraseCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) WalletPassphraseCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan WalletPassphraseRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// WalletPassphraseGetRes returns a pointer to the value in the Result field
func (a API) WalletPassphraseGetRes() (out *None, e error) {
	out, _ = a.Result.(*None)
	e, _ = a.Result.(error)
	return 
}

// WalletPassphraseWait calls the method and blocks until it returns or 5 seconds passes
func (a API) WalletPassphraseWait(cmd *btcjson.WalletPassphraseCmd) (out *None, e error) {
	RPCHandlers["walletpassphrase"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan WalletPassphraseRes):
		out, e = o.Res, o.e
	}
	return
}

// WalletPassphraseChange calls the method with the given parameters
func (a API) WalletPassphraseChange(cmd *btcjson.WalletPassphraseChangeCmd) (e error) {
	RPCHandlers["walletpassphrasechange"].Call <- API{a.Ch, cmd, nil}
	return
}

// WalletPassphraseChangeCheck checks if a new message arrived on the result channel and returns true if it does, as well as 
// storing the value in the Result field
func (a API) WalletPassphraseChangeCheck() (isNew bool) {
	select {
	case o := <- a.Ch.(chan WalletPassphraseChangeRes):
		if o.e != nil {
			a.Result = o.e
		} else {
			a.Result = o.Res
		}
		isNew = true
	default:
	}
	return
}

// WalletPassphraseChangeGetRes returns a pointer to the value in the Result field
func (a API) WalletPassphraseChangeGetRes() (out *None, e error) {
	out, _ = a.Result.(*None)
	e, _ = a.Result.(error)
	return 
}

// WalletPassphraseChangeWait calls the method and blocks until it returns or 5 seconds passes
func (a API) WalletPassphraseChangeWait(cmd *btcjson.WalletPassphraseChangeCmd) (out *None, e error) {
	RPCHandlers["walletpassphrasechange"].Call <- API{a.Ch, cmd, nil}
	select {
	case <-time.After(time.Second*5):
		break
	case o := <- a.Ch.(chan WalletPassphraseChangeRes):
		out, e = o.Res, o.e
	}
	return
}


// RunAPI starts up the api handler server that receives rpc.API messages and runs the handler and returns the result
// Note that the parameters are type asserted to prevent the consumer of the API from sending wrong message types not
// because it's necessary since they are interfaces end to end
func RunAPI(chainRPC *chainclient.RPCClient, wallet *Wallet, 
	quit qu.C) {
	nrh := RPCHandlers
	go func() {
		D.Ln("starting up wallet cAPI")
		var e error
		var res interface{}
		for {
			select { 
			case msg := <-nrh["addmultisigaddress"].Call:
				if res, e = nrh["addmultisigaddress"].
					Handler(msg.Params.(*btcjson.AddMultisigAddressCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(string); ok { 
					msg.Ch.(chan AddMultiSigAddressRes) <- AddMultiSigAddressRes{&r, e} } 
			case msg := <-nrh["createmultisig"].Call:
				if res, e = nrh["createmultisig"].
					Handler(msg.Params.(*btcjson.CreateMultisigCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(btcjson.CreateMultiSigResult); ok { 
					msg.Ch.(chan CreateMultiSigRes) <- CreateMultiSigRes{&r, e} } 
			case msg := <-nrh["createnewaccount"].Call:
				if res, e = nrh["createnewaccount"].
					Handler(msg.Params.(*btcjson.CreateNewAccountCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(None); ok { 
					msg.Ch.(chan CreateNewAccountRes) <- CreateNewAccountRes{&r, e} } 
			case msg := <-nrh["dropwallethistory"].Call:
				if res, e = nrh["dropwallethistory"].
					Handler(msg.Params.(*None), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(string); ok { 
					msg.Ch.(chan HandleDropWalletHistoryRes) <- HandleDropWalletHistoryRes{&r, e} } 
			case msg := <-nrh["dumpprivkey"].Call:
				if res, e = nrh["dumpprivkey"].
					Handler(msg.Params.(*btcjson.DumpPrivKeyCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(string); ok { 
					msg.Ch.(chan DumpPrivKeyRes) <- DumpPrivKeyRes{&r, e} } 
			case msg := <-nrh["getaccount"].Call:
				if res, e = nrh["getaccount"].
					Handler(msg.Params.(*btcjson.GetAccountCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(string); ok { 
					msg.Ch.(chan GetAccountRes) <- GetAccountRes{&r, e} } 
			case msg := <-nrh["getaccountaddress"].Call:
				if res, e = nrh["getaccountaddress"].
					Handler(msg.Params.(*btcjson.GetAccountAddressCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(string); ok { 
					msg.Ch.(chan GetAccountAddressRes) <- GetAccountAddressRes{&r, e} } 
			case msg := <-nrh["getaddressesbyaccount"].Call:
				if res, e = nrh["getaddressesbyaccount"].
					Handler(msg.Params.(*btcjson.GetAddressesByAccountCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.([]string); ok { 
					msg.Ch.(chan GetAddressesByAccountRes) <- GetAddressesByAccountRes{&r, e} } 
			case msg := <-nrh["getbalance"].Call:
				if res, e = nrh["getbalance"].
					Handler(msg.Params.(*btcjson.GetBalanceCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(float64); ok { 
					msg.Ch.(chan GetBalanceRes) <- GetBalanceRes{&r, e} } 
			case msg := <-nrh["getbestblock"].Call:
				if res, e = nrh["getbestblock"].
					Handler(msg.Params.(*None), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(btcjson.GetBestBlockResult); ok { 
					msg.Ch.(chan GetBestBlockRes) <- GetBestBlockRes{&r, e} } 
			case msg := <-nrh["getbestblockhash"].Call:
				if res, e = nrh["getbestblockhash"].
					Handler(msg.Params.(*None), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(string); ok { 
					msg.Ch.(chan GetBestBlockHashRes) <- GetBestBlockHashRes{&r, e} } 
			case msg := <-nrh["getblockcount"].Call:
				if res, e = nrh["getblockcount"].
					Handler(msg.Params.(*None), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(int32); ok { 
					msg.Ch.(chan GetBlockCountRes) <- GetBlockCountRes{&r, e} } 
			case msg := <-nrh["getinfo"].Call:
				if res, e = nrh["getinfo"].
					Handler(msg.Params.(*None), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(btcjson.InfoWalletResult); ok { 
					msg.Ch.(chan GetInfoRes) <- GetInfoRes{&r, e} } 
			case msg := <-nrh["getnewaddress"].Call:
				if res, e = nrh["getnewaddress"].
					Handler(msg.Params.(*btcjson.GetNewAddressCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(string); ok { 
					msg.Ch.(chan GetNewAddressRes) <- GetNewAddressRes{&r, e} } 
			case msg := <-nrh["getrawchangeaddress"].Call:
				if res, e = nrh["getrawchangeaddress"].
					Handler(msg.Params.(*btcjson.GetRawChangeAddressCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(string); ok { 
					msg.Ch.(chan GetRawChangeAddressRes) <- GetRawChangeAddressRes{&r, e} } 
			case msg := <-nrh["getreceivedbyaccount"].Call:
				if res, e = nrh["getreceivedbyaccount"].
					Handler(msg.Params.(*btcjson.GetReceivedByAccountCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(float64); ok { 
					msg.Ch.(chan GetReceivedByAccountRes) <- GetReceivedByAccountRes{&r, e} } 
			case msg := <-nrh["getreceivedbyaddress"].Call:
				if res, e = nrh["getreceivedbyaddress"].
					Handler(msg.Params.(*btcjson.GetReceivedByAddressCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(float64); ok { 
					msg.Ch.(chan GetReceivedByAddressRes) <- GetReceivedByAddressRes{&r, e} } 
			case msg := <-nrh["gettransaction"].Call:
				if res, e = nrh["gettransaction"].
					Handler(msg.Params.(*btcjson.GetTransactionCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(btcjson.GetTransactionResult); ok { 
					msg.Ch.(chan GetTransactionRes) <- GetTransactionRes{&r, e} } 
			case msg := <-nrh["getunconfirmedbalance"].Call:
				if res, e = nrh["getunconfirmedbalance"].
					Handler(msg.Params.(*btcjson.GetUnconfirmedBalanceCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(float64); ok { 
					msg.Ch.(chan GetUnconfirmedBalanceRes) <- GetUnconfirmedBalanceRes{&r, e} } 
			case msg := <-nrh["help"].Call:
				if res, e = nrh["help"].
					Handler(msg.Params.(btcjson.HelpCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(string); ok { 
					msg.Ch.(chan HelpNoChainRPCRes) <- HelpNoChainRPCRes{&r, e} } 
			case msg := <-nrh["importprivkey"].Call:
				if res, e = nrh["importprivkey"].
					Handler(msg.Params.(*btcjson.ImportPrivKeyCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(None); ok { 
					msg.Ch.(chan ImportPrivKeyRes) <- ImportPrivKeyRes{&r, e} } 
			case msg := <-nrh["keypoolrefill"].Call:
				if res, e = nrh["keypoolrefill"].
					Handler(msg.Params.(*None), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(None); ok { 
					msg.Ch.(chan KeypoolRefillRes) <- KeypoolRefillRes{&r, e} } 
			case msg := <-nrh["listaccounts"].Call:
				if res, e = nrh["listaccounts"].
					Handler(msg.Params.(*btcjson.ListAccountsCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(map[string]float64); ok { 
					msg.Ch.(chan ListAccountsRes) <- ListAccountsRes{&r, e} } 
			case msg := <-nrh["listaddresstransactions"].Call:
				if res, e = nrh["listaddresstransactions"].
					Handler(msg.Params.(*btcjson.ListAddressTransactionsCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.([]btcjson.ListTransactionsResult); ok { 
					msg.Ch.(chan ListAddressTransactionsRes) <- ListAddressTransactionsRes{&r, e} } 
			case msg := <-nrh["listalltransactions"].Call:
				if res, e = nrh["listalltransactions"].
					Handler(msg.Params.(*btcjson.ListAllTransactionsCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.([]btcjson.ListTransactionsResult); ok { 
					msg.Ch.(chan ListAllTransactionsRes) <- ListAllTransactionsRes{&r, e} } 
			case msg := <-nrh["listlockunspent"].Call:
				if res, e = nrh["listlockunspent"].
					Handler(msg.Params.(*None), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.([]btcjson.TransactionInput); ok { 
					msg.Ch.(chan ListLockUnspentRes) <- ListLockUnspentRes{&r, e} } 
			case msg := <-nrh["listreceivedbyaccount"].Call:
				if res, e = nrh["listreceivedbyaccount"].
					Handler(msg.Params.(*btcjson.ListReceivedByAccountCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.([]btcjson.ListReceivedByAccountResult); ok { 
					msg.Ch.(chan ListReceivedByAccountRes) <- ListReceivedByAccountRes{&r, e} } 
			case msg := <-nrh["listreceivedbyaddress"].Call:
				if res, e = nrh["listreceivedbyaddress"].
					Handler(msg.Params.(*btcjson.ListReceivedByAddressCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(btcjson.ListReceivedByAddressResult); ok { 
					msg.Ch.(chan ListReceivedByAddressRes) <- ListReceivedByAddressRes{&r, e} } 
			case msg := <-nrh["listsinceblock"].Call:
				if res, e = nrh["listsinceblock"].
					Handler(msg.Params.(btcjson.ListSinceBlockCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(btcjson.ListSinceBlockResult); ok { 
					msg.Ch.(chan ListSinceBlockRes) <- ListSinceBlockRes{&r, e} } 
			case msg := <-nrh["listtransactions"].Call:
				if res, e = nrh["listtransactions"].
					Handler(msg.Params.(*btcjson.ListTransactionsCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.([]btcjson.ListTransactionsResult); ok { 
					msg.Ch.(chan ListTransactionsRes) <- ListTransactionsRes{&r, e} } 
			case msg := <-nrh["listunspent"].Call:
				if res, e = nrh["listunspent"].
					Handler(msg.Params.(*btcjson.ListUnspentCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.([]btcjson.ListUnspentResult); ok { 
					msg.Ch.(chan ListUnspentRes) <- ListUnspentRes{&r, e} } 
			case msg := <-nrh["renameaccount"].Call:
				if res, e = nrh["renameaccount"].
					Handler(msg.Params.(*btcjson.RenameAccountCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(None); ok { 
					msg.Ch.(chan RenameAccountRes) <- RenameAccountRes{&r, e} } 
			case msg := <-nrh["sendfrom"].Call:
				if res, e = nrh["sendfrom"].
					Handler(msg.Params.(btcjson.LockUnspentCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(bool); ok { 
					msg.Ch.(chan LockUnspentRes) <- LockUnspentRes{&r, e} } 
			case msg := <-nrh["sendmany"].Call:
				if res, e = nrh["sendmany"].
					Handler(msg.Params.(*btcjson.SendManyCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(string); ok { 
					msg.Ch.(chan SendManyRes) <- SendManyRes{&r, e} } 
			case msg := <-nrh["sendtoaddress"].Call:
				if res, e = nrh["sendtoaddress"].
					Handler(msg.Params.(*btcjson.SendToAddressCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(string); ok { 
					msg.Ch.(chan SendToAddressRes) <- SendToAddressRes{&r, e} } 
			case msg := <-nrh["settxfee"].Call:
				if res, e = nrh["settxfee"].
					Handler(msg.Params.(*btcjson.SetTxFeeCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(bool); ok { 
					msg.Ch.(chan SetTxFeeRes) <- SetTxFeeRes{&r, e} } 
			case msg := <-nrh["signmessage"].Call:
				if res, e = nrh["signmessage"].
					Handler(msg.Params.(*btcjson.SignMessageCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(string); ok { 
					msg.Ch.(chan SignMessageRes) <- SignMessageRes{&r, e} } 
			case msg := <-nrh["signrawtransaction"].Call:
				if res, e = nrh["signrawtransaction"].
					Handler(msg.Params.(btcjson.SignRawTransactionCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(btcjson.SignRawTransactionResult); ok { 
					msg.Ch.(chan SignRawTransactionRes) <- SignRawTransactionRes{&r, e} } 
			case msg := <-nrh["validateaddress"].Call:
				if res, e = nrh["validateaddress"].
					Handler(msg.Params.(*btcjson.ValidateAddressCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(btcjson.ValidateAddressWalletResult); ok { 
					msg.Ch.(chan ValidateAddressRes) <- ValidateAddressRes{&r, e} } 
			case msg := <-nrh["verifymessage"].Call:
				if res, e = nrh["verifymessage"].
					Handler(msg.Params.(*btcjson.VerifyMessageCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(bool); ok { 
					msg.Ch.(chan VerifyMessageRes) <- VerifyMessageRes{&r, e} } 
			case msg := <-nrh["walletislocked"].Call:
				if res, e = nrh["walletislocked"].
					Handler(msg.Params.(*None), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(bool); ok { 
					msg.Ch.(chan WalletIsLockedRes) <- WalletIsLockedRes{&r, e} } 
			case msg := <-nrh["walletlock"].Call:
				if res, e = nrh["walletlock"].
					Handler(msg.Params.(*None), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(None); ok { 
					msg.Ch.(chan WalletLockRes) <- WalletLockRes{&r, e} } 
			case msg := <-nrh["walletpassphrase"].Call:
				if res, e = nrh["walletpassphrase"].
					Handler(msg.Params.(*btcjson.WalletPassphraseCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(None); ok { 
					msg.Ch.(chan WalletPassphraseRes) <- WalletPassphraseRes{&r, e} } 
			case msg := <-nrh["walletpassphrasechange"].Call:
				if res, e = nrh["walletpassphrasechange"].
					Handler(msg.Params.(*btcjson.WalletPassphraseChangeCmd), wallet, 
						chainRPC); E.Chk(e) {
				}
				if r, ok := res.(None); ok { 
					msg.Ch.(chan WalletPassphraseChangeRes) <- WalletPassphraseChangeRes{&r, e} } 
			case <-quit.Wait():
				D.Ln("stopping wallet cAPI")
				return
			}
		}
	}()
}

// RPC API functions to use with net/rpc

func (c *CAPI) AddMultiSigAddress(req *btcjson.AddMultisigAddressCmd, resp string) (e error) {
	nrh := RPCHandlers
	res := nrh["addmultisigaddress"].Result()
	res.Params = req
	nrh["addmultisigaddress"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) CreateMultiSig(req *btcjson.CreateMultisigCmd, resp btcjson.CreateMultiSigResult) (e error) {
	nrh := RPCHandlers
	res := nrh["createmultisig"].Result()
	res.Params = req
	nrh["createmultisig"].Call <- res
	select {
	case resp = <-res.Ch.(chan btcjson.CreateMultiSigResult):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) CreateNewAccount(req *btcjson.CreateNewAccountCmd, resp None) (e error) {
	nrh := RPCHandlers
	res := nrh["createnewaccount"].Result()
	res.Params = req
	nrh["createnewaccount"].Call <- res
	select {
	case resp = <-res.Ch.(chan None):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) HandleDropWalletHistory(req *None, resp string) (e error) {
	nrh := RPCHandlers
	res := nrh["dropwallethistory"].Result()
	res.Params = req
	nrh["dropwallethistory"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) DumpPrivKey(req *btcjson.DumpPrivKeyCmd, resp string) (e error) {
	nrh := RPCHandlers
	res := nrh["dumpprivkey"].Result()
	res.Params = req
	nrh["dumpprivkey"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) GetAccount(req *btcjson.GetAccountCmd, resp string) (e error) {
	nrh := RPCHandlers
	res := nrh["getaccount"].Result()
	res.Params = req
	nrh["getaccount"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) GetAccountAddress(req *btcjson.GetAccountAddressCmd, resp string) (e error) {
	nrh := RPCHandlers
	res := nrh["getaccountaddress"].Result()
	res.Params = req
	nrh["getaccountaddress"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) GetAddressesByAccount(req *btcjson.GetAddressesByAccountCmd, resp []string) (e error) {
	nrh := RPCHandlers
	res := nrh["getaddressesbyaccount"].Result()
	res.Params = req
	nrh["getaddressesbyaccount"].Call <- res
	select {
	case resp = <-res.Ch.(chan []string):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) GetBalance(req *btcjson.GetBalanceCmd, resp float64) (e error) {
	nrh := RPCHandlers
	res := nrh["getbalance"].Result()
	res.Params = req
	nrh["getbalance"].Call <- res
	select {
	case resp = <-res.Ch.(chan float64):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) GetBestBlock(req *None, resp btcjson.GetBestBlockResult) (e error) {
	nrh := RPCHandlers
	res := nrh["getbestblock"].Result()
	res.Params = req
	nrh["getbestblock"].Call <- res
	select {
	case resp = <-res.Ch.(chan btcjson.GetBestBlockResult):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) GetBestBlockHash(req *None, resp string) (e error) {
	nrh := RPCHandlers
	res := nrh["getbestblockhash"].Result()
	res.Params = req
	nrh["getbestblockhash"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) GetBlockCount(req *None, resp int32) (e error) {
	nrh := RPCHandlers
	res := nrh["getblockcount"].Result()
	res.Params = req
	nrh["getblockcount"].Call <- res
	select {
	case resp = <-res.Ch.(chan int32):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) GetInfo(req *None, resp btcjson.InfoWalletResult) (e error) {
	nrh := RPCHandlers
	res := nrh["getinfo"].Result()
	res.Params = req
	nrh["getinfo"].Call <- res
	select {
	case resp = <-res.Ch.(chan btcjson.InfoWalletResult):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) GetNewAddress(req *btcjson.GetNewAddressCmd, resp string) (e error) {
	nrh := RPCHandlers
	res := nrh["getnewaddress"].Result()
	res.Params = req
	nrh["getnewaddress"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) GetRawChangeAddress(req *btcjson.GetRawChangeAddressCmd, resp string) (e error) {
	nrh := RPCHandlers
	res := nrh["getrawchangeaddress"].Result()
	res.Params = req
	nrh["getrawchangeaddress"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) GetReceivedByAccount(req *btcjson.GetReceivedByAccountCmd, resp float64) (e error) {
	nrh := RPCHandlers
	res := nrh["getreceivedbyaccount"].Result()
	res.Params = req
	nrh["getreceivedbyaccount"].Call <- res
	select {
	case resp = <-res.Ch.(chan float64):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) GetReceivedByAddress(req *btcjson.GetReceivedByAddressCmd, resp float64) (e error) {
	nrh := RPCHandlers
	res := nrh["getreceivedbyaddress"].Result()
	res.Params = req
	nrh["getreceivedbyaddress"].Call <- res
	select {
	case resp = <-res.Ch.(chan float64):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) GetTransaction(req *btcjson.GetTransactionCmd, resp btcjson.GetTransactionResult) (e error) {
	nrh := RPCHandlers
	res := nrh["gettransaction"].Result()
	res.Params = req
	nrh["gettransaction"].Call <- res
	select {
	case resp = <-res.Ch.(chan btcjson.GetTransactionResult):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) GetUnconfirmedBalance(req *btcjson.GetUnconfirmedBalanceCmd, resp float64) (e error) {
	nrh := RPCHandlers
	res := nrh["getunconfirmedbalance"].Result()
	res.Params = req
	nrh["getunconfirmedbalance"].Call <- res
	select {
	case resp = <-res.Ch.(chan float64):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) HelpNoChainRPC(req btcjson.HelpCmd, resp string) (e error) {
	nrh := RPCHandlers
	res := nrh["help"].Result()
	res.Params = req
	nrh["help"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) ImportPrivKey(req *btcjson.ImportPrivKeyCmd, resp None) (e error) {
	nrh := RPCHandlers
	res := nrh["importprivkey"].Result()
	res.Params = req
	nrh["importprivkey"].Call <- res
	select {
	case resp = <-res.Ch.(chan None):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) KeypoolRefill(req *None, resp None) (e error) {
	nrh := RPCHandlers
	res := nrh["keypoolrefill"].Result()
	res.Params = req
	nrh["keypoolrefill"].Call <- res
	select {
	case resp = <-res.Ch.(chan None):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) ListAccounts(req *btcjson.ListAccountsCmd, resp map[string]float64) (e error) {
	nrh := RPCHandlers
	res := nrh["listaccounts"].Result()
	res.Params = req
	nrh["listaccounts"].Call <- res
	select {
	case resp = <-res.Ch.(chan map[string]float64):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) ListAddressTransactions(req *btcjson.ListAddressTransactionsCmd, resp []btcjson.ListTransactionsResult) (e error) {
	nrh := RPCHandlers
	res := nrh["listaddresstransactions"].Result()
	res.Params = req
	nrh["listaddresstransactions"].Call <- res
	select {
	case resp = <-res.Ch.(chan []btcjson.ListTransactionsResult):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) ListAllTransactions(req *btcjson.ListAllTransactionsCmd, resp []btcjson.ListTransactionsResult) (e error) {
	nrh := RPCHandlers
	res := nrh["listalltransactions"].Result()
	res.Params = req
	nrh["listalltransactions"].Call <- res
	select {
	case resp = <-res.Ch.(chan []btcjson.ListTransactionsResult):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) ListLockUnspent(req *None, resp []btcjson.TransactionInput) (e error) {
	nrh := RPCHandlers
	res := nrh["listlockunspent"].Result()
	res.Params = req
	nrh["listlockunspent"].Call <- res
	select {
	case resp = <-res.Ch.(chan []btcjson.TransactionInput):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) ListReceivedByAccount(req *btcjson.ListReceivedByAccountCmd, resp []btcjson.ListReceivedByAccountResult) (e error) {
	nrh := RPCHandlers
	res := nrh["listreceivedbyaccount"].Result()
	res.Params = req
	nrh["listreceivedbyaccount"].Call <- res
	select {
	case resp = <-res.Ch.(chan []btcjson.ListReceivedByAccountResult):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) ListReceivedByAddress(req *btcjson.ListReceivedByAddressCmd, resp btcjson.ListReceivedByAddressResult) (e error) {
	nrh := RPCHandlers
	res := nrh["listreceivedbyaddress"].Result()
	res.Params = req
	nrh["listreceivedbyaddress"].Call <- res
	select {
	case resp = <-res.Ch.(chan btcjson.ListReceivedByAddressResult):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) ListSinceBlock(req btcjson.ListSinceBlockCmd, resp btcjson.ListSinceBlockResult) (e error) {
	nrh := RPCHandlers
	res := nrh["listsinceblock"].Result()
	res.Params = req
	nrh["listsinceblock"].Call <- res
	select {
	case resp = <-res.Ch.(chan btcjson.ListSinceBlockResult):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) ListTransactions(req *btcjson.ListTransactionsCmd, resp []btcjson.ListTransactionsResult) (e error) {
	nrh := RPCHandlers
	res := nrh["listtransactions"].Result()
	res.Params = req
	nrh["listtransactions"].Call <- res
	select {
	case resp = <-res.Ch.(chan []btcjson.ListTransactionsResult):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) ListUnspent(req *btcjson.ListUnspentCmd, resp []btcjson.ListUnspentResult) (e error) {
	nrh := RPCHandlers
	res := nrh["listunspent"].Result()
	res.Params = req
	nrh["listunspent"].Call <- res
	select {
	case resp = <-res.Ch.(chan []btcjson.ListUnspentResult):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) RenameAccount(req *btcjson.RenameAccountCmd, resp None) (e error) {
	nrh := RPCHandlers
	res := nrh["renameaccount"].Result()
	res.Params = req
	nrh["renameaccount"].Call <- res
	select {
	case resp = <-res.Ch.(chan None):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) LockUnspent(req btcjson.LockUnspentCmd, resp bool) (e error) {
	nrh := RPCHandlers
	res := nrh["sendfrom"].Result()
	res.Params = req
	nrh["sendfrom"].Call <- res
	select {
	case resp = <-res.Ch.(chan bool):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) SendMany(req *btcjson.SendManyCmd, resp string) (e error) {
	nrh := RPCHandlers
	res := nrh["sendmany"].Result()
	res.Params = req
	nrh["sendmany"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) SendToAddress(req *btcjson.SendToAddressCmd, resp string) (e error) {
	nrh := RPCHandlers
	res := nrh["sendtoaddress"].Result()
	res.Params = req
	nrh["sendtoaddress"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) SetTxFee(req *btcjson.SetTxFeeCmd, resp bool) (e error) {
	nrh := RPCHandlers
	res := nrh["settxfee"].Result()
	res.Params = req
	nrh["settxfee"].Call <- res
	select {
	case resp = <-res.Ch.(chan bool):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) SignMessage(req *btcjson.SignMessageCmd, resp string) (e error) {
	nrh := RPCHandlers
	res := nrh["signmessage"].Result()
	res.Params = req
	nrh["signmessage"].Call <- res
	select {
	case resp = <-res.Ch.(chan string):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) SignRawTransaction(req btcjson.SignRawTransactionCmd, resp btcjson.SignRawTransactionResult) (e error) {
	nrh := RPCHandlers
	res := nrh["signrawtransaction"].Result()
	res.Params = req
	nrh["signrawtransaction"].Call <- res
	select {
	case resp = <-res.Ch.(chan btcjson.SignRawTransactionResult):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) ValidateAddress(req *btcjson.ValidateAddressCmd, resp btcjson.ValidateAddressWalletResult) (e error) {
	nrh := RPCHandlers
	res := nrh["validateaddress"].Result()
	res.Params = req
	nrh["validateaddress"].Call <- res
	select {
	case resp = <-res.Ch.(chan btcjson.ValidateAddressWalletResult):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) VerifyMessage(req *btcjson.VerifyMessageCmd, resp bool) (e error) {
	nrh := RPCHandlers
	res := nrh["verifymessage"].Result()
	res.Params = req
	nrh["verifymessage"].Call <- res
	select {
	case resp = <-res.Ch.(chan bool):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) WalletIsLocked(req *None, resp bool) (e error) {
	nrh := RPCHandlers
	res := nrh["walletislocked"].Result()
	res.Params = req
	nrh["walletislocked"].Call <- res
	select {
	case resp = <-res.Ch.(chan bool):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) WalletLock(req *None, resp None) (e error) {
	nrh := RPCHandlers
	res := nrh["walletlock"].Result()
	res.Params = req
	nrh["walletlock"].Call <- res
	select {
	case resp = <-res.Ch.(chan None):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) WalletPassphrase(req *btcjson.WalletPassphraseCmd, resp None) (e error) {
	nrh := RPCHandlers
	res := nrh["walletpassphrase"].Result()
	res.Params = req
	nrh["walletpassphrase"].Call <- res
	select {
	case resp = <-res.Ch.(chan None):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

func (c *CAPI) WalletPassphraseChange(req *btcjson.WalletPassphraseChangeCmd, resp None) (e error) {
	nrh := RPCHandlers
	res := nrh["walletpassphrasechange"].Result()
	res.Params = req
	nrh["walletpassphrasechange"].Call <- res
	select {
	case resp = <-res.Ch.(chan None):
	case <-time.After(c.Timeout):
	case <-c.quit.Wait():
	} 
	return 
}

// Client call wrappers for a CAPI client with a given Conn

func (r *CAPIClient) AddMultiSigAddress(cmd ...*btcjson.AddMultisigAddressCmd) (res string, e error) {
	var c *btcjson.AddMultisigAddressCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.AddMultiSigAddress", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) CreateMultiSig(cmd ...*btcjson.CreateMultisigCmd) (res btcjson.CreateMultiSigResult, e error) {
	var c *btcjson.CreateMultisigCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.CreateMultiSig", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) CreateNewAccount(cmd ...*btcjson.CreateNewAccountCmd) (res None, e error) {
	var c *btcjson.CreateNewAccountCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.CreateNewAccount", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) HandleDropWalletHistory(cmd ...*None) (res string, e error) {
	var c *None
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.HandleDropWalletHistory", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) DumpPrivKey(cmd ...*btcjson.DumpPrivKeyCmd) (res string, e error) {
	var c *btcjson.DumpPrivKeyCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.DumpPrivKey", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) GetAccount(cmd ...*btcjson.GetAccountCmd) (res string, e error) {
	var c *btcjson.GetAccountCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.GetAccount", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) GetAccountAddress(cmd ...*btcjson.GetAccountAddressCmd) (res string, e error) {
	var c *btcjson.GetAccountAddressCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.GetAccountAddress", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) GetAddressesByAccount(cmd ...*btcjson.GetAddressesByAccountCmd) (res []string, e error) {
	var c *btcjson.GetAddressesByAccountCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.GetAddressesByAccount", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) GetBalance(cmd ...*btcjson.GetBalanceCmd) (res float64, e error) {
	var c *btcjson.GetBalanceCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.GetBalance", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) GetBestBlock(cmd ...*None) (res btcjson.GetBestBlockResult, e error) {
	var c *None
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.GetBestBlock", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) GetBestBlockHash(cmd ...*None) (res string, e error) {
	var c *None
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.GetBestBlockHash", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) GetBlockCount(cmd ...*None) (res int32, e error) {
	var c *None
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.GetBlockCount", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) GetInfo(cmd ...*None) (res btcjson.InfoWalletResult, e error) {
	var c *None
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.GetInfo", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) GetNewAddress(cmd ...*btcjson.GetNewAddressCmd) (res string, e error) {
	var c *btcjson.GetNewAddressCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.GetNewAddress", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) GetRawChangeAddress(cmd ...*btcjson.GetRawChangeAddressCmd) (res string, e error) {
	var c *btcjson.GetRawChangeAddressCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.GetRawChangeAddress", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) GetReceivedByAccount(cmd ...*btcjson.GetReceivedByAccountCmd) (res float64, e error) {
	var c *btcjson.GetReceivedByAccountCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.GetReceivedByAccount", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) GetReceivedByAddress(cmd ...*btcjson.GetReceivedByAddressCmd) (res float64, e error) {
	var c *btcjson.GetReceivedByAddressCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.GetReceivedByAddress", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) GetTransaction(cmd ...*btcjson.GetTransactionCmd) (res btcjson.GetTransactionResult, e error) {
	var c *btcjson.GetTransactionCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.GetTransaction", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) GetUnconfirmedBalance(cmd ...*btcjson.GetUnconfirmedBalanceCmd) (res float64, e error) {
	var c *btcjson.GetUnconfirmedBalanceCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.GetUnconfirmedBalance", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) HelpNoChainRPC(cmd ...btcjson.HelpCmd) (res string, e error) {
	var c btcjson.HelpCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.HelpNoChainRPC", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) ImportPrivKey(cmd ...*btcjson.ImportPrivKeyCmd) (res None, e error) {
	var c *btcjson.ImportPrivKeyCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.ImportPrivKey", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) KeypoolRefill(cmd ...*None) (res None, e error) {
	var c *None
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.KeypoolRefill", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) ListAccounts(cmd ...*btcjson.ListAccountsCmd) (res map[string]float64, e error) {
	var c *btcjson.ListAccountsCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.ListAccounts", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) ListAddressTransactions(cmd ...*btcjson.ListAddressTransactionsCmd) (res []btcjson.ListTransactionsResult, e error) {
	var c *btcjson.ListAddressTransactionsCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.ListAddressTransactions", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) ListAllTransactions(cmd ...*btcjson.ListAllTransactionsCmd) (res []btcjson.ListTransactionsResult, e error) {
	var c *btcjson.ListAllTransactionsCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.ListAllTransactions", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) ListLockUnspent(cmd ...*None) (res []btcjson.TransactionInput, e error) {
	var c *None
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.ListLockUnspent", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) ListReceivedByAccount(cmd ...*btcjson.ListReceivedByAccountCmd) (res []btcjson.ListReceivedByAccountResult, e error) {
	var c *btcjson.ListReceivedByAccountCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.ListReceivedByAccount", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) ListReceivedByAddress(cmd ...*btcjson.ListReceivedByAddressCmd) (res btcjson.ListReceivedByAddressResult, e error) {
	var c *btcjson.ListReceivedByAddressCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.ListReceivedByAddress", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) ListSinceBlock(cmd ...btcjson.ListSinceBlockCmd) (res btcjson.ListSinceBlockResult, e error) {
	var c btcjson.ListSinceBlockCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.ListSinceBlock", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) ListTransactions(cmd ...*btcjson.ListTransactionsCmd) (res []btcjson.ListTransactionsResult, e error) {
	var c *btcjson.ListTransactionsCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.ListTransactions", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) ListUnspent(cmd ...*btcjson.ListUnspentCmd) (res []btcjson.ListUnspentResult, e error) {
	var c *btcjson.ListUnspentCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.ListUnspent", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) RenameAccount(cmd ...*btcjson.RenameAccountCmd) (res None, e error) {
	var c *btcjson.RenameAccountCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.RenameAccount", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) LockUnspent(cmd ...btcjson.LockUnspentCmd) (res bool, e error) {
	var c btcjson.LockUnspentCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.LockUnspent", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) SendMany(cmd ...*btcjson.SendManyCmd) (res string, e error) {
	var c *btcjson.SendManyCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.SendMany", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) SendToAddress(cmd ...*btcjson.SendToAddressCmd) (res string, e error) {
	var c *btcjson.SendToAddressCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.SendToAddress", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) SetTxFee(cmd ...*btcjson.SetTxFeeCmd) (res bool, e error) {
	var c *btcjson.SetTxFeeCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.SetTxFee", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) SignMessage(cmd ...*btcjson.SignMessageCmd) (res string, e error) {
	var c *btcjson.SignMessageCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.SignMessage", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) SignRawTransaction(cmd ...btcjson.SignRawTransactionCmd) (res btcjson.SignRawTransactionResult, e error) {
	var c btcjson.SignRawTransactionCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.SignRawTransaction", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) ValidateAddress(cmd ...*btcjson.ValidateAddressCmd) (res btcjson.ValidateAddressWalletResult, e error) {
	var c *btcjson.ValidateAddressCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.ValidateAddress", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) VerifyMessage(cmd ...*btcjson.VerifyMessageCmd) (res bool, e error) {
	var c *btcjson.VerifyMessageCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.VerifyMessage", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) WalletIsLocked(cmd ...*None) (res bool, e error) {
	var c *None
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.WalletIsLocked", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) WalletLock(cmd ...*None) (res None, e error) {
	var c *None
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.WalletLock", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) WalletPassphrase(cmd ...*btcjson.WalletPassphraseCmd) (res None, e error) {
	var c *btcjson.WalletPassphraseCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.WalletPassphrase", c, &res); E.Chk(e) {
	}
	return
}

func (r *CAPIClient) WalletPassphraseChange(cmd ...*btcjson.WalletPassphraseChangeCmd) (res None, e error) {
	var c *btcjson.WalletPassphraseChangeCmd
	if len(cmd) > 0 {
		c = cmd[0]
	}
	if e = r.Call("CAPI.WalletPassphraseChange", c, &res); E.Chk(e) {
	}
	return
}

